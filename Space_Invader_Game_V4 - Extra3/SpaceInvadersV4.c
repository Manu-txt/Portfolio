// SpaceInvaders.c
// Runs on TM4C123
// Starter file for CECS 347 Project 2 - Space Invaders
// Min He
// November 15, 2022

// Reference:
// http://www.spaceinvaders.de/
// sounds at http://www.classicgaming.cc/classics/spaceinvaders/sounds.php
// http://www.classicgaming.cc/classics/spaceinvaders/playguide.php
/* The original example code comes the books
   "Embedded Systems: Real Time Interfacing to Arm Cortex M Microcontrollers",
   ISBN: 978-1463590154, Jonathan Valvano, copyright (c) 2013

   "Embedded Systems: Introduction to Arm Cortex M Microcontrollers",
   ISBN: 978-1469998749, Jonathan Valvano, copyright (c) 2013

 Copyright 2013 by Jonathan W. Valvano, valvano@mail.utexas.edu
    You may use, edit, run or distribute this file
    as long as the above copyright notice remains
 THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 VALVANO SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
 OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 For more information about my classes, my research, and my books, see
 http://users.ece.utexas.edu/~valvano/
 */
 
 // ******* Required Hardware I/O connections*******************
// Slide pot pin 1 connected to ground
// Slide pot pin 2 connected to Ain8 (PE5)
// Slide pot pin 3 connected to pne side of the 1k resistor
// other side of the 1k resistor is connected to +3.3V 
// Onboard sw1(left push button): fire button 
// Onboard sw2(right push button): game start button

// Nokia 5110: interface with SSI2
// ---------------
// Signal        (Nokia 5110) LaunchPad pin
// Reset         (RST) connected to ?
// SSI0Fss       (CE) connected to ?
// Data/Command  (DC) connected to ?
// SSI0Tx        (Din) connected to ?
// SSI0Clk       (Clk) connected to ?
// 3.3V          (Vcc) power
// back light    (BL) not connected, consists of 4 white LEDs which draw ~80mA total
// Ground        (Gnd) ground


#include "tm4c123gh6pm.h"
#include "Nokia5110.h"
#include "PLL.h"
#include "switch.h"
#include "Systick.h"
#include "ADC1SS3.h"
#include "Sound.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include "DAC.h"

// enemy that starts at the top of the screen (arms/mouth closed)
// width=16 x height=10


const unsigned char SmallEnemyPointA[][200] = {{
// SmallEnemy30PointA
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},

 { // SmallEnemy20PointA
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},

 { // SmallEnemy10PointA
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F,
 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}};


const unsigned char SmallEnemyPointB[][200] = {{
// enemy that starts at the top of the screen (arms/mouth open)
// width=16 x height=10, SmallEnemy30PointB
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x0F, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
 0xFF, 0x0F, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},

// enemy ship that starts in the middle of the screen (arms apart)
// width=16 x height=10, SmallEnemy20PointB
{
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0,
 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0x0F, 0xF0, 0x0F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},

 // enemy ship that starts at the bottom of the screen (arms up)
// width=16 x height=10,SmallEnemy10PointB
{
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
 0xF0, 0xFF, 0xFF, 0x0F, 0xFF, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}};


// image of the player's ship
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=18 x height=8
const unsigned char PlayerShip0[] = {
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA,
 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

  // a missile in flight
// includes one blacked out row on the top, bottom, and right of the image to prevent smearing when moved 1 pixel down, up, or left
// width=4 x height=9
const unsigned char Missile0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00,
 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

  // a missile in flight
// includes one blacked out row on the top, bottom, and left of the image to prevent smearing when moved 1 pixel down, up, or right
// width=4 x height=9
const unsigned char Missile1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F,
 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a missile after it hits something
// width=4 x height=9
const unsigned char Missile2[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// a laser burst in flight
// includes one blacked out row on the top and bottom of the image to prevent smearing when moved 1 pixel up or down
// width=2 x height=9
const unsigned char Laser0[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 0x00,
 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// blank space to cover a laser after it hits something
// width=2 x height=9
const unsigned char Laser1[] = {
 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};

// small explosion best used for the demise of an enemy
// width=16 x height=10
const unsigned char SmallExplosion0[] = {
 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
 0x0F, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF};


enum game_status{OVER,ON};
enum life_status{DEAD, ALIVE};
enum enemy_posture{CLOSE, OPEN};

#define PLAYERW     ((unsigned char)PlayerShip0[18])
#define PLAYERH     ((unsigned char)PlayerShip0[22])
#define ENEMY10W    16  
#define LASERH      9
#define LASERW      2
#define BULLETH     LASERH
#define BULLETW     LASERW
#define LEVEL1_ENEMIES 3
#define LEVEL2_ENEMIES 4
#define LEVEL3_ENEMIES 5
#define MAX_TOTAL_ENEMIES LEVEL3_ENEMIES


struct State {
  uint8_t x;      // x coordinate
  uint8_t y;      // y coordinate
  const uint8_t *image; // ptr->image
  bool life;            // 0=dead, 1=alive
};          
typedef struct State STyp;
STyp Enemy[MAX_TOTAL_ENEMIES];
STyp PlayerShip;
STyp Bullet, SmallExplosion;

#define ENEMY_WIDTH 18
#define MAX_ENEMYX MAX_X-ENEMY_WIDTH

// Function prototypes
extern void EnableInterrupts(void);  // defined in startup.s
extern void DisableInterrupts(void); // defined in startup.s

void Game_Init(void);
void Move(void);
void Draw(void);
void Start_Prompt(void);
void End_Prompt(void);
void System_Init(void);
void Delay100ms(unsigned long count);
void SysTick_Wait3s(void);


// global variables used for game control
volatile  bool time_to_draw=false;
 bool game_s=false;
 bool reset_score=false;
uint8_t counter = 0;
unsigned short playerScore = 0;
uint8_t sw1Pressed = 0;
#define NUM_ENEMIES 3   // Number of enemies in the game
bool enemySpawned[MAX_TOTAL_ENEMIES];   // Track if the enemy has spawned
uint16_t enemySpawnTimer[MAX_TOTAL_ENEMIES]; // Timer for each enemy spawn
bool allEnemiesDone = true;
uint8_t currentLevel = 1;
uint8_t numEnemies = LEVEL1_ENEMIES;
uint8_t enemySpeed[MAX_TOTAL_ENEMIES];


int main(void){
	System_Init();
  while(1){
    Start_Prompt();

		while(game_s==OVER){};
    
		Game_Init(); // all sprites: 3 sprites
    Draw();
    while (game_s==ON) {
      if (time_to_draw){
        Move();
        Draw();
        time_to_draw = 0;
      } 
    }
    
    End_Prompt();
  }
}

void System_Init(void){
  DisableInterrupts();
  PLL_Init(); 	// set system clock to 80 MHz
	DAC_Init();
	Sound_Init();
	SysTick_Init();
	Switch_Init();
  ADC1SS3_Init();
  Nokia5110_Init();
  EnableInterrupts();

}

// Display the game start prompt
void Start_Prompt(void){
	Nokia5110_Clear();
	Nokia5110_SetCursor(0,1);
	Nokia5110_OutString("Space");
	Nokia5110_SetCursor(0,2);
	Nokia5110_OutString("Invader");
	Nokia5110_SetCursor(0,3);
	Nokia5110_OutString("Press SW2");
	Nokia5110_SetCursor(0,4);
	Nokia5110_OutString("To Start");	
}

// Display the game end prompt for 2 seconds
void End_Prompt(void){
	char message[20];
	sprintf(message, "%d", playerScore);
	DisableInterrupts();
	GPIO_PORTD_DATA_R = 0x00;
	Nokia5110_Clear();
	Nokia5110_SetCursor(0,1);
	Nokia5110_OutString("Game Over");
	Nokia5110_SetCursor(0,2);
	Nokia5110_OutString("Nice Try!");
	Nokia5110_SetCursor(0,3);
	Nokia5110_OutString("Your Score");
	Nokia5110_SetCursor(0,4); 
	Nokia5110_OutString(message);
	EnableInterrupts();
	SysTick_Wait3s();
}

// Initialize the game: initialize all sprites and 
// reset refresh control and game status.
void Game_Init(void){
  time_to_draw=0;
	game_s = ON;
	uint8_t i;
	
	if (reset_score == true) {
    playerScore = 0;   // reset the actual score
		currentLevel = 1;
  }
	
	// Extra Credit
	if (currentLevel == 1) {
    numEnemies = LEVEL1_ENEMIES;
  } else if (currentLevel == 2) {
    numEnemies = LEVEL2_ENEMIES;
  } else if (currentLevel == 3) {
		numEnemies = LEVEL3_ENEMIES;
	}
	
	// Version 1: add enemy initialization with close posture.
  for (i = 0; i < numEnemies; i++) {
    Enemy[i].x = 0;       // Start from left side of the screen
    Enemy[i].y = 10 + (i * 10);  // Spread enemies across different rows
    Enemy[i].image = SmallEnemyPointA[i % 3]; // Set initial image for each enemy
    Enemy[i].life = DEAD;   // Enemies are initially not alive

    enemySpawned[i] = false;
		if (currentLevel == 3) {
            enemySpawnTimer[i] = (i % 2 == 0) ? i * 5 : i * 15;
            enemySpeed[i] = (i % 2 == 0) ? 2 : 1;
        } else {
            enemySpawnTimer[i] = i * (currentLevel == 1 ? 20 : 10);
            enemySpeed[i] = currentLevel;
        }
  }

  
  // Version 2: add player ship initialization
	PlayerShip.x = MAX_X/2;
	PlayerShip.y = MAX_Y-1;
	PlayerShip.image = PlayerShip0;
	PlayerShip.life = 1;
   
  // Version 3: Add bullet initialization: you can choose Laser or Missile
	Bullet.x = PlayerShip.x;
	Bullet.y = PlayerShip.y+8;
	Bullet.image = Laser0;
	Bullet.life = 0;
	
	// Explosion
	SmallExplosion.x = Bullet.x;
	SmallExplosion.y = Bullet.y;
	SmallExplosion.life = 0;
	
}

// Update positions for all alive sprites.
void Move(void) {
    uint8_t i;
    uint16_t ADC_Value;
    uint8_t x_position;
    
    // Player movement control
    ADC_Value = ADC1SS3_In();
    x_position = ADCValue_To_X_AXIS(ADC_Value, MAX_X);
    if (x_position < 0) x_position = 0;
    else if (x_position > MAX_X - PLAYERW) x_position = MAX_X - PLAYERW;
    PlayerShip.x = x_position;

    // Bullet firing
    if(sw1Pressed && Bullet.life == 0) {
        Bullet.x = PlayerShip.x + 8;
        Bullet.y = PlayerShip.y - 7;
        Bullet.life = 1;
        sw1Pressed = 0;
        Sound_Shoot();
    }

    // Enemy management
    bool allSpawned = true;
    bool allDead = true;
    static bool firstGroupDefeated = false;
    static bool lastEnemyActivated = false;

    for (i = 0; i < numEnemies; i++) {
        // Enemy spawning logic
        if (!enemySpawned[i]) {
            if (currentLevel == 3) {
                // Pyramid group spawns immediately
                if (i < 4) {
                    enemySpawnTimer[i] = 0;
                }
                // Other enemies wait
                else if (!firstGroupDefeated) {
                    enemySpawnTimer[i] = 1;
                    allSpawned = false;
                    continue;
                }
                // Special handling for last enemy
                else if (i == numEnemies-1 && !lastEnemyActivated) {
                    // Wait until only 1 enemy remains before spawning last enemy
                    uint8_t aliveCount = 0;
                    for (uint8_t j = 4; j < numEnemies-1; j++) {
                        if (Enemy[j].life == ALIVE) aliveCount++;
                    }
                    if (aliveCount <= 1) {
                        enemySpawnTimer[i] = 0;
                        lastEnemyActivated = true;
                    } else {
                        enemySpawnTimer[i] = 1;
                        allSpawned = false;
                        continue;
                    }
                }
            }
            
            if (enemySpawnTimer[i] > 0) {
                enemySpawnTimer[i]--;
                allSpawned = false;
            } else {
                Enemy[i].life = ALIVE;
                enemySpawned[i] = true;
            }
        }

        // Enemy movement
        if (Enemy[i].life == ALIVE) {
            allDead = false;
            
            if (currentLevel == 3) {
                // Pyramid enemies (slow)
                if (i < 4) {
                    Enemy[i].x += 1;
                } 
                // Last enemy (super fast)
                else if (i == numEnemies-1) {
                    // Speed increases as it crosses screen
                    uint8_t speedBoost = (Enemy[i].x > MAX_X/2) ? 3 : 0;
                    Enemy[i].x += 4 + speedBoost; // Base speed 4, up to 7
                    
                    // Zig-zag movement pattern
                    if (Enemy[i].x % 20 == 0) {
                        Enemy[i].y += (Enemy[i].x % 40 == 0) ? 2 : -2;
                    }
                }
                // Other enemies (normal fast)
                else {
                    Enemy[i].x += 2;
                }
            } else {
                Enemy[i].x += enemySpeed[i];
            }

            // Animation
            if(Enemy[i].image == SmallEnemyPointA[i % 3]) {
                Enemy[i].image = SmallEnemyPointB[i % 3];
            } else {
                Enemy[i].image = SmallEnemyPointA[i % 3];
            }

            // Boundary check
            if (Enemy[i].x >= MAX_ENEMYX) {
                Enemy[i].life = DEAD;
            }
        }
    }

    // Check if pyramid group is defeated
    if (currentLevel == 3 && !firstGroupDefeated) {
        bool groupDefeated = true;
        for (i = 0; i < 4; i++) {
            if (Enemy[i].life == ALIVE || !enemySpawned[i]) {
                groupDefeated = false;
                break;
            }
        }
        if (groupDefeated) {
            firstGroupDefeated = true;
            // Start spawning normal fast enemies
            for (i = 4; i < numEnemies-1; i++) {
                enemySpawnTimer[i] = (i-4) * 15;
            
            }
        }
    }

    // Bullet collision detection
    if(Bullet.life) {
        for(i = 0; i < numEnemies; i++) {
            if(Enemy[i].life == ALIVE &&
               Bullet.x + BULLETW >= Enemy[i].x &&
               Bullet.x <= Enemy[i].x + ENEMY10W &&
               Bullet.y + BULLETH >= Enemy[i].y &&
               Bullet.y <= Enemy[i].y + 10) {
                
                Enemy[i].life = DEAD;
                SmallExplosion.x = Enemy[i].x;
                SmallExplosion.y = Enemy[i].y;
                SmallExplosion.life = 1;
                Bullet.life = 0;
                
                // Bonus points for last enemy
                playerScore += (currentLevel == 3 && i == numEnemies-1) ? 5 : 1;
                
                Sound_Killed();
                break;
            }
        }
        if(Bullet.life) {
            if(Bullet.y > 2) {
                Bullet.y -= 3;
            } else {
                Bullet.life = 0;
            }
        }
    }

    // Explosion animation
    if(SmallExplosion.life) {
        counter++;
        SmallExplosion.image = SmallExplosion0;
        if(counter >= 3) {
            SmallExplosion.life = 0;
            counter = 0;
        }
    }

    // Level progression
    if (allSpawned && allDead) {
        if (currentLevel == 1) {
            currentLevel = 2;
            numEnemies = LEVEL2_ENEMIES;
            for (i = 0; i < numEnemies; i++) {
                Enemy[i].x = 0;
                Enemy[i].y = 10 + (i * 10);
                Enemy[i].life = DEAD;
                enemySpawned[i] = false;
                enemySpawnTimer[i] = i * 10;
                enemySpeed[i] = 2;
            }
						// Level transition display
        Nokia5110_ClearBuffer();
        //Nokia5110_SetCursor(0, 2);
        if (currentLevel == 2){ 
					Nokia5110_SetCursor(0,1);
					Nokia5110_OutString("Move To");
					Nokia5110_SetCursor(0,2);
					Nokia5110_OutString("LEVEL 2!");
					SysTick_Wait3s();
					Nokia5110_DisplayBuffer();
				}
        } 
        else if (currentLevel == 2) {
            currentLevel = 3;
            numEnemies = LEVEL3_ENEMIES;
            firstGroupDefeated = false;
            lastEnemyActivated = false;
            for (i = 0; i < numEnemies; i++) {
                // Pyramid formation (3-1)
                if (i < 3) {
                    Enemy[i].y = 20;
                    Enemy[i].x = 10 + i * 20;
                } 
                else if (i == 3) {
                    Enemy[i].y = 30;
                    Enemy[i].x = 30;
                }
                else {
                    Enemy[i].y = 10 + (i-4) * 8;
                    Enemy[i].x = 0;
                }
                Enemy[i].life = DEAD;
                enemySpawned[i] = false;
                enemySpawnTimer[i] = (i < 4) ? 0 : 1000;
                enemySpeed[i] = (i == numEnemies-1) ? 4 : (i < 4) ? 1 : 2;
            }
						// Level transition display
        Nokia5110_ClearBuffer();
        //Nokia5110_SetCursor(0, 2);
        if (currentLevel == 3){ 
					Nokia5110_SetCursor(0,1);
					Nokia5110_OutString("Move To");
					Nokia5110_SetCursor(0,2);
					Nokia5110_OutString("LEVEL 3!");
					SysTick_Wait3s();
					Nokia5110_DisplayBuffer();
				}
        } 
        else {
            game_s = OVER;
            reset_score = true;
        }
    }
}
// Update the screen: 
// clear display and update the screen with the 
// current positions of all sprites that are alive.
void Draw(void){
	static uint8_t enemy_posture = CLOSE;  // enemy start with close posture: SmallEnemyPointA
  uint8_t i;
  
  if (game_s==OVER) return;
  Nokia5110_ClearBuffer();
  
  // V1:Update live enemies' positions in display buffer: screen[]
  for(i=0;i<numEnemies;i++){
    if(Enemy[i].life == ALIVE){
			Nokia5110_PrintBMP(Enemy[i].x, Enemy[i].y, Enemy[i].image, 0);
    }
  }
	
	// V2: Update the playership position in display buffer: screen[]
	Nokia5110_PrintBMP(PlayerShip.x, PlayerShip.y, PlayerShip.image, 0); 
	  
	// V3: Update the bullet position in display buffer if there is one.
	if(Bullet.life){
		// V4: if bullet is just activated, play the shoot sound here
		Sound_Shoot();
		
		Nokia5110_PrintBMP(Bullet.x, Bullet.y, Bullet.image,0);
	}
	
	if(SmallExplosion.life){
		Nokia5110_PrintBMP(SmallExplosion.x, SmallExplosion.y, SmallExplosion.image,0);
	}

  // Update the display with information in display buffer screen[].
	Nokia5110_DisplayBuffer();
}

// Control screen refresh rate. 
void SysTick_Handler(void){
	// signal time to refresh
	time_to_draw = true;
}

void GPIOPortF_Handler(void){    // called on release of either SW1 or SW2
	// take care of button debounce  
	Delay100ms(10);
	
	// SW1: shoot a bullet if there is none.
  if(GPIO_PORTF_RIS_R&SW1_MASK){  // SW1 pressed
    GPIO_PORTF_ICR_R = SW1_MASK;		// acknowledge flag4
		sw1Pressed = !sw1Pressed;
	}
  // SW2: start the game, change the game status to ON
  if(GPIO_PORTF_RIS_R&SW2_MASK){  // SW2 pressed
    GPIO_PORTF_ICR_R = SW2_MASK;  // acknowledge flag0
		game_s = ON;
  }
}

// Delay function used for game over prompt timing control: 2s
// To Do: modify the time constant used in the code to generate approximately 2s delay.
void Delay100ms(unsigned long count){
  unsigned long volatile time;
  while(count>0){
    time = 72724;  // 0.1sec at 16 MHz
    while(time){
	  	time--;
    }
    count--;
  }
}
